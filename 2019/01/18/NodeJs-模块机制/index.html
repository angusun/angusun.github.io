<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="description"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>NodeJs 模块机制</title><link rel="shortcut icon" href="/images/avatar.jpg" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">FLAMINGO</a></div><div class="about-me">HI~</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/angusun"></span><a href="https://github.com/angusun" target="_blank" title="https://github.com/angusun">https://github.com/angusun</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="flamingoxx77@gmail.com"></span><span>flamingoxx77@gmail.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="s411748304"></span><span>s411748304</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">NodeJs 模块机制</div><div class="date">写于2019年01月18日</div><div class="content"><h2 id="CommonJs规范"><a href="#CommonJs规范" class="headerlink" title="CommonJs规范"></a>CommonJs规范</h2><p>CommonJs对模块的定义非常简单，主要分为：模块引用、模块定义和模块标识3个部分。</p>
<h3 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&quot;math&quot;);</span><br></pre></td></tr></table></figure>
<p>在Commonjs中存在require()方法，该方法接收模块标识，一次引入一个模块的api到当前的上下文中。</p>
<h3 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h3><p>在模块中，上下文提供了require()方法来引入外部模块。相应的，上下文提供了exports对象用于导出当前模块的方法或变量，并且它是唯一导出的出口。在模块中，还存在着一个module对象，它代表模块本身，而exports是module的属性，在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exports.add = function()&#123;</span><br><span class="line">    var sum = 0,</span><br><span class="line">        i = 0,</span><br><span class="line">        args = arguments,</span><br><span class="line">        l = args.length;</span><br><span class="line">    whild(i&lt;l)&#123;</span><br><span class="line">        sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在另一个文件中，我们通过require()方法引入模块后，就可以调用定义的属性或方法了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var math = require(&apos;math&apos;); </span><br><span class="line">exports.increment = function (val) &#123; </span><br><span class="line">  return math.add(val, 1); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h3><p>模块标识其实就是传递给require()方法的参数，他必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。他可以没有文件名后缀.js。<br>模块的定义十分简单，接口也十分简洁。它的定义在于将类聚的方法和变量等限定在私有作用域中，同时支持引入和导出功能以顺畅的连接上下游依赖。如图所示，每个模块都有独立的空间，他们互相不干扰，在引用时也显得干净利落。</p>
<h2 id="Node的模块实现"><a href="#Node的模块实现" class="headerlink" title="Node的模块实现"></a>Node的模块实现</h2><p>在Node中引入模块，需要经历如下三个步骤：<br> 1.路径分析<br> 2.文件定位<br> 3.编译执行<br>在Node中模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p>
<h3 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h3><p>无论是核心模块还是文件模块，require()方法对于相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级。不同之处核心模块的缓存检查优先于文件模块的缓存检查</p>
<h3 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h3><h4 id="1-模块标识符分析"><a href="#1-模块标识符分析" class="headerlink" title="1.模块标识符分析"></a>1.模块标识符分析</h4><p>模块标识符分为以下几类：</p>
<ul>
<li>核心模块，如http、fs、path等。</li>
<li>.或..开始的相对路径文件模块。</li>
<li>以/开始的绝对路径文件模块。</li>
<li>非路径形式的文件模块，如自定义的connect模块。</li>
</ul>
<h4 id="2-文件定位"><a href="#2-文件定位" class="headerlink" title="2.文件定位"></a>2.文件定位</h4><p>在文件定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。</p>
<ul>
<li>文件扩展名分析<br>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况，。CommonJs模块规范也允许不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。<br>在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程，所以这里是一个会引起性能问题的地方。小诀窍：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。</li>
<li>目录分析和包</li>
</ul>
<h4 id="3-模块编译"><a href="#3-模块编译" class="headerlink" title="3.模块编译"></a>3.模块编译</h4><p>编译和执行时引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译，对于不同的文件扩展名，其载入方法也有所不同，具体如下所示：</p>
<ul>
<li>.js文件。通过fs模块同步读取文件后编译执行。</li>
<li>.node文件。这是c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。</li>
<li>.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</li>
<li>其余扩展名文件。他们被当做是js文件载入。</li>
</ul>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块分为C/C++编写的和JavaScript编写的两部分。其中C/C++文件存放在Node项目的src目录下，JavaScript文件存放在lib目录下。</p>
<h4 id="C-C-核心模块的编译过程"><a href="#C-C-核心模块的编译过程" class="headerlink" title="C/C++核心模块的编译过程"></a>C/C++核心模块的编译过程</h4><p><img src="http://i.imgur.com/twMDCAe.png" alt="依赖层级关系"></p>
<h4 id="核心模块的引入流程"><a href="#核心模块的引入流程" class="headerlink" title="核心模块的引入流程"></a>核心模块的引入流程</h4><p><img src="http://i.imgur.com/e03Ho5w.png" alt="os原生模块引入流程"></p>
<h4 id="编写核心模块"><a href="#编写核心模块" class="headerlink" title="编写核心模块"></a>编写核心模块</h4><p>编写内建模块通常分为两步完成：编写头文件和编写C/C++文件。<br>1.讲一下代码保存为node_hello.h,存放在Node的src目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef NODE_HELLO_H_ </span><br><span class="line">#define NODE_HELLO_H_ </span><br><span class="line">#include &lt;v8.h&gt; </span><br><span class="line"></span><br><span class="line">namespace node &#123; </span><br><span class="line">  // 预定义方法 </span><br><span class="line">  v8::Handle&lt;v8::Value&gt; SayHello(const v8::Arguments&amp; args); </span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>2.编写node_hello.cc，并存储到src目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;node.h&gt; </span><br><span class="line">#include &lt;node_hello.h&gt; </span><br><span class="line">#include &lt;v8.h&gt; </span><br><span class="line"></span><br><span class="line">namespace node &#123; </span><br><span class="line"></span><br><span class="line">using namespace v8; </span><br><span class="line">// 实现预定义的方法 </span><br><span class="line">Handle&lt;Value&gt; SayHello(const Arguments&amp; args) &#123; </span><br><span class="line">  HandleScope scope; </span><br><span class="line">  return scope.Close(String::New(&quot;Hello world!&quot;)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 给传入的目标对象添加sayHello方法 </span><br><span class="line">void Init_Hello(Handle&lt;Object&gt; target) &#123; </span><br><span class="line">  target-&gt;Set(String::NewSymbol(&quot;sayHello&quot;), FunctionTemplate::New(SayHello)-&gt;GetFunction()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">// 调用NODE_MODULE()将注册方法定义到内存中 </span><br><span class="line">NODE_MODULE(node_hello, node::Init_Hello)</span><br></pre></td></tr></table></figure>
<p>以上两步完成了内部模块的编写，但是真正要让Node认为它是内部模块，还需要更改src/node_extensions.h，在NODE_EXT_LIST_END前添加NODE_EXT_LIST_ITEM(node_hello)，以将node_hello模块添加进node_module_list数组中。<br>其次还需要让编写的两份代码编译进执行文件，同事需要更改Node的项目生成文件node.gyp，并在’target_name’:’node’节点的sources中添加新编译的两个文件，然后编译真个Node项目。可以参考深入浅出nodejs一书附录A部分。<br>编译和安装后，直接在命令行中运行以下代码，将会得到期望的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node </span><br><span class="line">&gt; var hello = process.binding(&apos;hello&apos;); </span><br><span class="line">undefined </span><br><span class="line">&gt; hello.sayHello(); </span><br><span class="line">&apos;Hello world!&apos;</span><br></pre></td></tr></table></figure>
<h2 id="C-C-扩展模块"><a href="#C-C-扩展模块" class="headerlink" title="C/C++ 扩展模块"></a>C/C++ 扩展模块</h2><p>JavaScript的典型弱点就是位运算。Javascript的位运算参照Java的位运算实现，但是Java位运算是在int型数字基础上进行的，而JavaScript中只有double型的数据类型，在进行位运算的过程中，需要将double型转换为int型，然后在进行，所以JavaScript层面上做位运算的效率不高。</p>
<p>在应用中，会频繁出现位运算的需求，包括转码、编码等过程。如果通过JavaScript来实现，cpu资源会耗费很多，这是编写C/C++扩展模块来提升性能的机会来了。</p>
<p>C/C++扩展模块属于文件模块中的一类，前面讲述文件模块编译部分时提到，C/C++模块通过预先编译为.node文件，然后调用process.dlopen()方法加载执行，</p>
<p>node模块一定程度上可以跨平台，其前提条件是源代码可以支持在nix和windows上编译，在nix下通过编译为动态连接共享文件（.so），在Windows下则编译为动态链接库文件（.dll）。这里有一个让人迷惑的地方，那就是引用加载的时候却是.node文件。其实.node扩展名只是为了看起来更自然一点，不会因为平台的差异产生不同的感觉，实际上，在Windows下它是.dll文件，在*nix下它是.so文件。为了实现跨平台，dlopen()方法在内部实现区分平台，分别用的是加载.so和.dll的方式。</p>
<p>值得注意的是，一个平台的.node文件在另一个平台下是无法加载执行的，必须重新用各自平台下的编译器编译为正确的.node文件。</p>
<p><img src="http://i.imgur.com/BM8SitU.png" alt="扩展模块在不同平台上编译和加载过程"></p>
<h3 id="C-C-扩展模块的编写"><a href="#C-C-扩展模块的编写" class="headerlink" title="C/C++扩展模块的编写"></a>C/C++扩展模块的编写</h3><p>在介绍C/C++内建模块的时候，其实已经介绍了C/C++模块的编写方式，普通的扩展模块与内建模块区别在于无须将源代码编译进Node，而是通过dlopen()方法动态加载，所以在编写普通的扩展模块时，无须将源代码写进node命名空间，也不需要提供头文件。下面将采用同一个例子来介绍C/C++扩展模块的编写。<br>它的JavaScript原型代码与前面的例子一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.sayHello = function () &#123; </span><br><span class="line">  return &apos;Hello world!&apos;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新建hello目录作为自己的项目位置，编写hello.cc并将其存储到src目录下，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;node.h&gt; </span><br><span class="line">#include &lt;v8.h&gt; </span><br><span class="line"></span><br><span class="line">using namespace v8; </span><br><span class="line">// 实现预定义的方法 </span><br><span class="line">Handle&lt;Value&gt; SayHello(const Arguments&amp; args) &#123; </span><br><span class="line">  HandleScope scope; </span><br><span class="line">  return scope.Close(String::New(&quot;Hello world!&quot;)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 给传入的目标对象添加sayHello()方法 </span><br><span class="line">void Init_Hello(Handle&lt;Object&gt; target) &#123; </span><br><span class="line">  target-&gt;Set(String::NewSymbol(&quot;sayHello&quot;), FunctionTemplate::New(SayHello)-&gt;GetFunction()); </span><br><span class="line">&#125; </span><br><span class="line">// 调用NODE_MODULE()方法将注入方法定义到内存中 </span><br><span class="line">NODE_MODULE(hello, Init_Hello)</span><br></pre></td></tr></table></figure>
<p>C/C++扩展模块与内建模块的套路一样，将方法挂载在target对象上，然后通过NODE_MODULE声明即可。由于不像编写内建模块那样将对象声明到node_module_list链表中，所以无法被认作是一个原生模块，只能通过dlopen()来动态加载，然后导出给JavaScript调用。</p>
<h3 id="C-C-扩展模块的编译"><a href="#C-C-扩展模块的编译" class="headerlink" title="C/C++扩展模块的编译"></a>C/C++扩展模块的编译</h3><p>在GYP工具的帮助下，C/C++扩展模块的编译是一件省心的事情，无须为每个平台编写不同的项目编译文件。写好.gyp项目文件是除编码外的头等大事，然而你也无须担心此事太难，因为.gyp项目文件足够简单，node-gyp约定.gyp文件为binding.gyp，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &apos;targets&apos;: [ </span><br><span class="line">&#123; </span><br><span class="line">  &apos;target_name&apos;: &apos;hello&apos;, </span><br><span class="line">  &apos;sources&apos;: [ </span><br><span class="line">  &apos;src/hello.cc&apos; </span><br><span class="line">  ], </span><br><span class="line">  &apos;conditions&apos;: [ </span><br><span class="line">  [&apos;OS == &quot;win&quot;&apos;,  </span><br><span class="line">  &#123; </span><br><span class="line">  &apos;libraries&apos;: [&apos;-lnode.lib&apos;] </span><br><span class="line">  &#125; </span><br><span class="line">  ] </span><br><span class="line">  ] </span><br><span class="line">&#125; </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$node-gyp configure</span><br></pre></td></tr></table></figure>
<p>会得到如下的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">gyp info it worked if it ends with ok </span><br><span class="line">gyp info using node-gyp@0.8.3 </span><br><span class="line">gyp info using node@0.8.14 | darwin | x64 </span><br><span class="line">gyp info spawn python </span><br><span class="line">gyp info spawn args [ &apos;/usr/local/lib/node_modules/node-gyp/gyp/gyp&apos;, </span><br><span class="line">gyp info spawn args   &apos;binding.gyp&apos;, </span><br><span class="line">gyp info spawn args   &apos;-f&apos;, </span><br><span class="line">gyp info spawn args   &apos;make&apos;, </span><br><span class="line">gyp info spawn args   &apos;-I&apos;, </span><br><span class="line">gyp info spawn args   &apos;/Users/jacksontian/git/diveintonode/examples/02/addon/build/config.gypi&apos;, </span><br><span class="line">gyp info spawn args   &apos;-I&apos;, </span><br><span class="line">gyp info spawn args   &apos;/usr/local/lib/node_modules/node-gyp/addon.gypi&apos;, </span><br><span class="line">gyp info spawn args   &apos;-I&apos;, </span><br><span class="line">gyp info spawn args   &apos;/Users/jacksontian/.node-gyp/0.8.14/common.gypi&apos;, </span><br><span class="line">gyp info spawn args   &apos;-Dlibrary=shared_library&apos;, </span><br><span class="line">gyp info spawn args   &apos;-Dvisibility=default&apos;, </span><br><span class="line">gyp info spawn args   &apos;-Dnode_root_dir=/Users/jacksontian/.node-gyp/0.8.14&apos;, </span><br><span class="line">gyp info spawn args   &apos;-Dmodule_root_dir=/Users/jacksontian/git/diveintonode/examples/02/addon&apos;, </span><br><span class="line">gyp info spawn args   &apos;--depth=.&apos;, </span><br><span class="line">gyp info spawn args   &apos;--generator-output&apos;, </span><br><span class="line">gyp info spawn args   &apos;build&apos;, </span><br><span class="line">gyp info spawn args   &apos;-Goutput_dir=.&apos; ] </span><br><span class="line">gyp info ok</span><br></pre></td></tr></table></figure>
<p>node-gyp 指令会在当前目录中创建build目录，并生成系统相关的项目文件。在*nix平台下，build目录中会出现makefile等文件；在Windows下，则会生成vcxproj等文件，继续执行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node-gyp build</span><br></pre></td></tr></table></figure>
<p>会得到如下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gyp info it worked if it ends with ok </span><br><span class="line">gyp info using node-gyp@0.8.3 </span><br><span class="line">gyp info using node@0.8.14 | darwin | x64 </span><br><span class="line">gyp info spawn make </span><br><span class="line">gyp info spawn args [ &apos;BUILDTYPE=Release&apos;, &apos;-C&apos;, &apos;build&apos; ] </span><br><span class="line">  CXX(target) Release/obj.target/hello/hello.o </span><br><span class="line">  SOLINK_MODULE(target) Release/hello.node </span><br><span class="line">  SOLINK_MODULE(target) Release/hello.node: Finished </span><br><span class="line">gyp info ok</span><br></pre></td></tr></table></figure>
<p>编译完成后，hello.node文件会生成在build/release目录下。</p>
<h3 id="C-C-扩展模块的加载"><a href="#C-C-扩展模块的加载" class="headerlink" title="C/C++扩展模块的加载"></a>C/C++扩展模块的加载</h3><p>得道hello.node结果文件后，如何调用扩展模块其实在前面已经提及，require()方法通过解析标识符、路径分析、文件定位，然后加载执行即可，下面的代码引入前面编译得道的.node文件，并调用执行其中的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello = require(&apos;./build/Release/hello.node&apos;); </span><br><span class="line">console.log(hello.sayHello());</span><br></pre></td></tr></table></figure>
<p>将以上代码村委hello.js，调用node hello.js命令即可得道如下的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world！</span><br></pre></td></tr></table></figure>
<p>对于以node为扩展名的文件，Node将会调用process.dlopen()方法去加载文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Native extension for .node </span><br><span class="line">Module._extensions[&apos;.node&apos;] = process.dlopen;</span><br></pre></td></tr></table></figure>
<p>加载.node文件实际上经历了两个步骤，第一个步骤是调用uv_dlopen()方法去打开动态链接库，第二个步骤是调用uv_dlsym()方法找到动态链接库中通过NODE_MODULE宏定义的方法地址。这两个过程都是通过libuv库进行封装的：在*nix平台下实际上调用的是dlfcn.h头文件中定义的dlopen()和dlsym()两个方法；在Windows平台则是通过LoadLibraryExW()和GetProcAddress()这两个方法实现的，它们分别加载.so和.dll文件（实际为.node文件）。<br><img src="http://i.imgur.com/e9SHW1L.png" alt="require()引入.node文件过程"></p>
<h2 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h2><p>C/C++内建模块属于最底层的模块，他属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果你不是非常了解要调用的C/C++内建模块，就避免使用process.binding()方法直接调用，这不推荐。</p>
<p>JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，他不需要跟底层打交道，但是什么重要。<br><img src="http://i.imgur.com/sVyQY9e.png" alt="模块之间的调用关系"><br>文件模块通常是由第三方编写，包括普通JavaScript模块和C/C++扩展模块模块，主要调用方向为普通JavaScript模块调用扩展模块。</p>
<h3 id="前后端公用模块"><a href="#前后端公用模块" class="headerlink" title="前后端公用模块"></a>前后端公用模块</h3><p>JavaScript在Node出现之后，比别的编程语言多了一项优势，那就是一些模块可以在前后端实现公用，这是因为很多api在各个宿主环境下都提供。但是实际情况下，前后端环境是略有差异的。</p>
<h3 id="模块的侧重点"><a href="#模块的侧重点" class="headerlink" title="模块的侧重点"></a>模块的侧重点</h3><p>前后端JavaScript分别搁在HTTP的两端，他们扮演的角色不同，前端的JavaScript需要经历从同一个服务器分发到多个客户端执行，而服务器端JavaScript则是相同的代码需要多次执行。前者的瓶颈在于带宽，后者的瓶颈在于CPU和内存等资源。前者需要通过网络加载代码，后者从磁盘中加载，两者的加载速度不在一个数量级上。</p>
<p>纵观Node的模块引入过程，几乎都是同步的。尽管与Node强调异步的行为相反，但是它是合理的。但是如果前端模块采用同步的方式来引入，那将会在用户体验上造成很大的问题。UI在初始化过程中需要花费很多时间来等待脚本加载完成。</p>
<p>鉴于网络原因，CommonJs为后端JavaScript指定的规范并不完全适合前端的应用场景。经过一段争执之后，AMD规范最终在前端应用场景中胜出，它的全称是Asynchronous Module Define，即是“异步模块定义”,除此之外，还有玉伯定义的CMD规范。</p>
<h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p>AMD规范是CommonJs模块规范的一个延伸，它的模块定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?,dependencies,factory);</span><br></pre></td></tr></table></figure>
<p>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。下面的代码定义了一个简单的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(function()&#123;</span><br><span class="line">    var exports = &#123;&#125;;</span><br><span class="line">    exports.sayHello = function()&#123;</span><br><span class="line">        alert(&quot;Hello from module:&quot;+module.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    return exports;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不同之处在于AMD模块需要用define来明确定义一个模块，而在Node实现中隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。</p>
<h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p>CMD规范由国内的玉伯提出，与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;dep1&apos;,&apos;dep2&apos;],function(dep1,dep2)&#123;</span><br><span class="line">    return function()&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与AMD模块规范相比，CMD模块更接近于Node对CommonJs规范的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(factory);</span><br></pre></td></tr></table></figure>
<p>在依赖部分，CMD支持动态引入，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    // the module code goes here</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。</p>
<h3 id="兼容多种模块规范"><a href="#兼容多种模块规范" class="headerlink" title="兼容多种模块规范"></a>兼容多种模块规范</h3><p>为了让同一模块可以运行在前后端，在写作过程中需要考虑兼容前端也实现了模块规范的环境。为了保持前后端的一致性，类库开发者需要将类库代码包装在一个闭包内。以下代码演示如何将hello()方法定义到不同的运行环境中，它能够兼容Node、AMD、CMD以及常见的浏览器环境中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;(function (name, definition) &#123; </span><br><span class="line">  // 检测上ူ文环境是否为AMD或CMD </span><br><span class="line">  var hasDefine = typeof define === &apos;function&apos;, </span><br><span class="line">// 检查上下文环境是否为Node </span><br><span class="line">hasExports = typeof module !== &apos;undefined&apos; &amp;&amp; module.exports; </span><br><span class="line"></span><br><span class="line">  if (hasDefine) &#123; </span><br><span class="line">// AMD环境或CMD环境 </span><br><span class="line">define(definition); </span><br><span class="line">  &#125; else if (hasExports) &#123; </span><br><span class="line">// 定义为普通Node模块 </span><br><span class="line">module.exports = definition(); </span><br><span class="line">  &#125; else &#123; </span><br><span class="line">// 将模块的执行结果挂在window变量中，在浏览器中this指向window对象 </span><br><span class="line">this[name] = definition(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)(&apos;hello&apos;, function () &#123; </span><br><span class="line">  var hello = function () &#123;&#125;; </span><br><span class="line">  return hello; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a class="tag-link" href="/tags/NodeJs/">NodeJs</a></div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2019/01/21/NodeJs-异步编程/">NodeJs 异步编程</a></li><li>下一篇：<a href="/2011/01/17/hello-world/">Hello World</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-curry" target="_blank">Curry</a><span>.</span></div></footer><script src="/script/jquery.min.js"></script><script src="/script/index.js"></script><script src="/script/jquery.min.js"></script><script src="/script/index.js"></script><script src="/script/post.js"></script></body></html>